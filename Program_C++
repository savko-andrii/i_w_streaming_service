#include <iostream>
#include <string>
#include <vector>
#include <fstream>
#include <stdexcept>

using namespace std;

//Абстрактний клас Playable
class Playable {
public:
    virtual ~Playable() = default;

    virtual void show() const = 0;

    string getType() const {
        return "Playable item";
    }
};

//Song
class Song : public Playable {
private:
    string title;
    string artist;
    int duration;

    void validate() {
        if (duration <= 0)
            throw invalid_argument("Duration must be positive!");
    }

public:
    static int songsCreated;

    Song(string t, string a, int d)
        : title(t), artist(a), duration(d)
    {
        validate();
        songsCreated++;
    }

    Song(const Song& other)
        : title(other.title), artist(other.artist), duration(other.duration)
    {
    }

    const string& getTitle() const { return title; }
    const string& getArtist() const { return artist; }
    int getDuration() const { return duration; }

    void show() const override {
        cout << "Title: " << title
            << " | Artist: " << artist
            << " | Duration: " << duration << " sec\n";
    }

    string getType() const {
        return "Song";
    }
};

int Song::songsCreated = 0;


//Playlist
class Playlist {
private:
    vector<Playable*> items;
    string filename;

public:
    Playlist(const string& file) : filename(file) {
        load(); 
    }

    ~Playlist() {
        for (auto p : items) delete p;
    }

    void load() {
        ifstream fin(filename);

        if (!fin.is_open()) {
            ofstream create(filename);
            return;
        }

        string title, artist;
        int duration;

        while (getline(fin, title)) {
            if (!getline(fin, artist)) break;
            if (!(fin >> duration)) break;
            fin.ignore();

            items.push_back(new Song(title, artist, duration));
        }
    }

    void save() {
        ofstream fout(filename);
        for (auto p : items) {
            const Song* s = dynamic_cast<const Song*>(p);
            if (!s) continue;

            fout << s->getTitle() << "\n";
            fout << s->getArtist() << "\n";
            fout << s->getDuration() << "\n";
        }
    }

    void addSong(const Playable& p) {
        const Song* s = dynamic_cast<const Song*>(&p);
        if (!s) throw runtime_error("Invalid playable type (expected Song)!");

        items.push_back(new Song(*s));

        save(); 
    }

    void showAll() const {
        if (items.empty())
            throw runtime_error("Playlist is empty!");

        cout << "\n--- PLAYLIST ---\n";
        for (auto p : items)
            p->show();
    }
};


int main() {
    const string filename = "songs.txt";

    try {
        Playlist pl(filename);

        cout << "Choose mode:\n";
        cout << "1 — Author (add new songs)\n";
        cout << "2 — Listener (view playlist)\n";
        cout << "Your choice: ";

        int mode;
        if (!(cin >> mode)) throw runtime_error("Invalid input!");
        cin.ignore();

        if (mode == 1) {
            while (true) {
                string title, artist;
                int duration;

                cout << "Song title: ";
                getline(cin, title);

                cout << "Artist: ";
                getline(cin, artist);

                cout << "Duration (sec): ";
                while (!(cin >> duration)) {
                    cin.clear();
                    string bad;
                    getline(cin, bad);
                    cout << "Invalid input. Enter duration: ";
                }
                cin.ignore();

                Playable* p = new Song(title, artist, duration);

                pl.addSong(*p) // раннє

                delete p;

                cout << "Add another song? (y/n): ";
                char c;
                cin >> c;
                cin.ignore();
                if (!(c == 'y' || c == 'Y')) break;
            }
        }
        else if (mode == 2) {
            pl.showAll(); //пізнє
        }
        else {
            cout << "Invalid option.\n";
        }

        cout << "\nSongs created total: " << Song::songsCreated << "\n";
        cout << "Program finished.\n";
    }
    catch (invalid_argument& e) {
        cerr << "Input error: " << e.what() << "\n";
    }
    catch (runtime_error& e) {
        cerr << "Runtime problem: " << e.what() << "\n";
    }
    catch (exception& e) {
        cerr << "Unexpected error: " << e.what() << "\n";
    }

    return 0;
}
